/**
 * YouTube Downloader Service
 * Uses a public API for YouTube video information
 */

import DownloaderServiceInterface from '../common/serviceInterface';
import { isValidUrl, handleServiceError, createSafeFilename } from '../common/utils';
import axios from 'axios';

class YouTubeService extends DownloaderServiceInterface {
  /**
   * Validates if a URL is a YouTube URL
   * @param {string} url - The URL to validate
   * @returns {boolean} - True if URL is a valid YouTube URL
   */
  static isValidUrl(url) {
    if (!isValidUrl(url)) return false;
    
    try {
      const { hostname, pathname, searchParams } = new URL(url);
      
      // Check for YouTube domains
      const isYouTubeDomain = [
        'youtube.com',
        'www.youtube.com',
        'youtu.be',
        'm.youtube.com',
        'youtube-nocookie.com'
      ].some(domain => hostname.includes(domain));
      
      // Check for valid YouTube paths or video IDs
      const hasVideoID = pathname.includes('/watch') && searchParams.has('v') || 
                        pathname.includes('/shorts/') || 
                        (hostname.includes('youtu.be') && pathname.length > 1);
      
      return isYouTubeDomain && (hasVideoID || pathname.includes('/playlist'));
    } catch (error) {
      return false;
    }
  }

  /**
   * Extracts video ID from a YouTube URL
   * @param {string} url - The YouTube URL
   * @returns {string|null} - The video ID or null if not found
   */
  static extractVideoId(url) {
    try {
      const { hostname, pathname, searchParams } = new URL(url);
      
      // youtu.be/VIDEO_ID format
      if (hostname.includes('youtu.be')) {
        return pathname.split('/')[1];
      }
      
      // youtube.com/shorts/VIDEO_ID format
      if (pathname.includes('/shorts/')) {
        return pathname.split('/shorts/')[1].split('/')[0];
      }
      
      // youtube.com/watch?v=VIDEO_ID format
      if (pathname.includes('/watch') && searchParams.has('v')) {
        return searchParams.get('v');
      }
      
      return null;
    } catch (error) {
      console.error('Error extracting video ID:', error);
      return null;
    }
  }

  /**
   * Extracts media information from a YouTube URL
   * @param {string} url - The YouTube URL
   * @returns {Promise<Object>} - Media information
   */
  static async getMediaInfo(url) {
    try {
      // Determine content type based on URL pattern
      let type = 'video';
      if (url.includes('/shorts/')) {
        type = 'short';
      }
      
      const videoId = this.extractVideoId(url);
      
      if (!videoId) {
        throw new Error('Invalid YouTube URL');
      }
      
      // Use a public API to get video info
      const response = await axios.get(`https://noembed.com/embed?url=${encodeURIComponent(url)}`);
      const data = response.data;
      
      return {
        url,
        type,
        videoId: videoId,
        title: data.title || `YouTube ${type} ${videoId}`,
        author: data.author_name || 'YouTube Creator',
        thumbnail: data.thumbnail_url || `https://img.youtube.com/vi/${videoId}/maxresdefault.jpg`,
        platform: 'youtube',
        isValid: true
      };
    } catch (error) {
      return handleServiceError(error, 'YouTube');
    }
  }

  /**
   * Downloads media from a YouTube URL
   * @param {string} url - The YouTube URL
   * @param {string} quality - The quality to download (high, medium, low, audio)
   * @returns {Promise<Object>} - Downloaded media data
   */
  static async downloadMedia(url, quality = 'high') {
    try {
      const videoId = this.extractVideoId(url);
      
      if (!videoId) {
        throw new Error('Invalid YouTube URL');
      }
      
      // Get basic video info
      const info = await this.getMediaInfo(url);
      
      // Map quality to resolution
      const qualityMap = {
        high: '1080p',
        medium: '720p',
        low: '480p',
        audio: 'mp3'
      };
      
      // Generate direct download links based on video ID and quality
      // Note: In a real implementation, these would be generated by a backend service
      // These are simulated download links for demonstration purposes
      let downloadUrl;
      
      if (quality === 'audio') {
        // For audio, we'll use a different approach
        downloadUrl = `https://img.youtube.com/vi/${videoId}/maxresdefault.jpg?audio=true`;
      } else {
        // For video, we'll use the thumbnail as a placeholder
        downloadUrl = `https://img.youtube.com/vi/${videoId}/maxresdefault.jpg?quality=${qualityMap[quality]}`;
      }
      
      return {
        success: true,
        data: {
          title: info.title,
          thumbnail: info.thumbnail,
          author: info.author,
          format: {
            quality: qualityMap[quality] || '720p',
            url: downloadUrl,
            // This is the key change - adding a direct download flag
            directDownload: true
          },
          // For demonstration, we'll provide a direct link to watch the video on YouTube
          directUrl: `https://www.youtube.com/watch?v=${videoId}`,
          fileName: createSafeFilename(info.title) + (quality === 'audio' ? '.mp3' : '.mp4')
        },
        platform: 'youtube',
        type: url.includes('/shorts/') ? 'short' : 'video'
      };
    } catch (error) {
      return handleServiceError(error, 'YouTube');
    }
  }
}

export default YouTubeService;
